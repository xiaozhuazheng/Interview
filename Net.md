## 记录计算机基础、网络

### 1、计算机网络结构
![avatar](/image/net_1.png)

便于理解，通常采用五层协议的结构：<br/>

应用层：<br/>
应用层是通过应用进程间的交互来完成特定的网络应用。对于不同的网络应用对应着不同的应用层协议，比如常见的万维网应用的Http协议，支持文件传送的FTP协议等。<br/><br/>
传输层：<br/>
传输层为两个进程间的通信提供通用的数据传送服务。所谓通用，不是增对某一特定的网络应用，而是多种应用使用同一套传输协议，主要使用TCP/UDP两种协议：<br/>
传输控制协议TCP：提供面向连接的、可靠的数据传输服务，数据传输的单位为报文段。<br/>
用户数据报协议UDP：提供无连接的、提供最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输单位为用户数据报。<br/><br/>
网络层：<br/>
网络层负责为分组交换机上的不同主机提供通信服务。网络层把传输层产生的报文段或者用户数据报封装成分组或者包进行传送。由于网络层采用IP协议，因此分组也叫做IP数据报。庞大的互联网是由大量的异构网络通过路由器相连，采用无连接的网际协议IP和许多种路由选择协议，因此网络层也通常被叫做IP层。<br/><br/>
数据链路层：<br/>
两台主机进行数据交互时，总是在一段段链路上进行，这就需要专门的链路层协议。两个相连链路节点进行数据传送时，会先将网络层交下来的分组封装成帧，每一帧包含数据和必要的控制信息(同步信息、地址信息、差错控制信息等)。<br/><br/>
物理层：<br/>
数据在物理层是以比特为单位进行传输的。发送方发送1(或0)时，接收方应当收到0(或1).因此物理层需要通过不同的电压来代表0或1，以及接收方如何识别出发送方发送的比特。值得注意的时，传递信息所用到的一些物理媒介，比如网线，光缆等，并不数据物理层范围之类，而是在物理层的下面，通常称作0层。<br/><br/>

上面概述了网络结构中的每一层结构，那么实际的传输环境下，它们是如何运作的呢？<br/>
![avatar](/image/net_2.png)

如上图，当主机1的应用进程Ap1向主机2的应用进程Ap2传送数据时，Ap1先将数据交给应用层处理，并一层一层的根据对应的协议封装数据后，从上至下，然后通过路由将数据传送到Ap2的物理层，并由下至上解析数据，最后通过应用层交给网络应用处理数据，反之亦然。

### 2、TCP/UDP
#### UDP：
* UDP是无连接的，即发送数据前是不需要建立连接的，当然数据传输结束后也就没有断开连接的操作，因此节省了开销和发送数据前的时延；
* 使用最大努力交互，即不保证数据的可靠交互，因此主机不需要维持复杂的连接状态表；
* UDP是面向报文的。<br/><br/>
![avatar](/image/net_3.png)

当发送方的UDP收到应用层的报文后，在添加首部后就直接向下传递给网络层，对收到的报文不进行合并、拆分等操作；当收到网络层传递的报文后，直接去掉首部后就向上传递给应用层。那么UDP添加的首部是什么格式呢：<br/><br/>
![avatar](/image/net_4.png)

当传输层收到从IP层的UDP数据报时，就根据首部中的目的端口号，将UDP数据传递到对应的端口，上交到最终点应用进程。
* UDP没有拥塞控制，这对某些实时应用是很重要的；
* UDP支持一对一、一对多、多对一、多对多的交互通信；
* UDP首部开销小，只有8个字节，比TCP的20个字节的首部要短。
#### TCP：
概述：<br/>
* TCP是面向连接的运输层协议，在进行数据传输前必须先建立可靠连接，数据传输结束后需要释放已建立好的可靠连接，类似于我们生活中的打电话；
* TCP提供可靠的连接传输服务，保证传输数据的无差错、不丢失、不重复并按序到达；
* 每一条TCP连接只能有两个端点，即点对点连接；
* TCP提供全双工通信，通信双发在任何时候都可以发送数据，则得于TCP连接的两端都设有发送缓存和接受缓存。发送数据时，应用程序把数据发送给TCP缓存，就可以去做其他事了，TCP会在合适的时候从缓存里将数据发送出去；在接受数据时，TCP将IP层的数据写入缓存，应用程序在合适的时候就从缓存里取出数据；
* 面向字节流。虽然应用程序和TCP交互的是一块块大小不等的数据块，但TCP把这些数据块仅仅是当作一连串无结构的字节流，TCP并不知道所传输字节流的含义。如下图：<br/>
![avatar](/image/net_5.png)

TCP连接：<br/>
TCP的连接为点对点的连接，每一端通过套接字进行抽象，IP地址和端口号拼接成套接字。<br/>
Socket = IP地址:端口号<br/>
TCP连接 ::= {socket1 : socket2} = {(IP1:port1) : (IP2:port2)}<br/><br/>

可靠传输：<br/>
上面提到，TCP传输是可靠的，那么是什么样的工作原理来保证的呢。这里引入“停止等待”的概念，所谓停止等待，是TCP每发送完一组分组，就进入停止发送，等待对方确认。当收到对方确认后，才进行下一次发送。这里分情况讨论：<br/>
无差错情况：<br/>
![avatar](/image/net_6.png)

正常情况下，A发送消息给B，并等待B消息确认，当B确认消息后，A再发送消息M2.....依次有序的进行下去；<br/>

消息出现差错：<br/>
![avatar](/image/net_7.png)

当A发送消息M1给B，但是M1在发送的过程中存在差错，那么B收到M1后，就会丢弃M1，后面不进行任何操作。此时A已经进入等待状态，但是不可能一直等待下去，当超时计时器时间结束后，A会重发消息M1，后面就进入正常情况下的数据传输状态。<br/>

确认消息丢失：<br/>
![avatar](/image/net_8.png)

如图所示，当B收到A发送的消息M1后，并且确认M1无差错，那么就给A发送确认消息。但是确认消息丢失了，A在超时计时器结束后重新发送消息M1，B第二次收到M1后，丢弃重复的M1，并再次对A发送确认消息。<br/>

确认消息迟到：<br/>
![avatar](/image/net_9.png)

上面的情况是B收到M1后向A发送的消息迟到了，A在超时计时器结束后还是会向B发送M1，B收到M1后丢弃重复的M1，并再次向A发送确认消息，当A第二次再收到确认消息时，此时判断为消息迟到，则将重复的确认消息丢弃，不做任何操作。<br/><br/>

连续ARQ：<br/>
上面提到的可靠传输方式通常被称作“自动重传请求ARQ”，意思是重传的请求是发送方自动发起的。但是值得注意的是，每次发送消息都需要等待对方确认后才能发送下一个消息，这样导致传输效率，或者说信道利用率很低。怎么办呢，“连续ARQ”：<br/>

![avatar](/image/net_10.png)

又名滑动窗口协议，是TCP协议的精髓。如图锁所示，位于滑动窗口内的5个分组连续被发送，而不需要等待接收方的确认消息。当发送方每收到一次消息确认后，就将滑动窗口向前移动一格分组。<br/>

TCP虽然是面向字节流，但发送的数据单元为数据报。一个TCP报文分为首部和数据部分，TCP的全部功能都体现在首部中的各个字段控制。<br/>
![avatar](/image/net_11.png)

### 3、三次握手、四次挥手
三次握手以及四次挥手都是针对TCP，分别为TCP的连接与释放。先理解几个控制位概念：<br/>
* 确认ACK 仅当ACK = 1时确认号字段才有效，当ACK = 0 时确认号是无效的。TCP规定，在建立连接后所有传送报文段都必须把ACK置1。
* 同步SYN 在连接时用来同步序号。当SYN = 1，ACK = 0时，表示这是一条连接请求报文，若对方同意连接，则在响应报文中将SYN = 1，ACK= 1。因此，当SYN = 1表示这是一条连接请求或连接响应报文。
* 终止 用来释放连接。当FIN = 1时，表明此报文的发送发数据发送完毕，并且要求释放连接。
#### 三次握手：
![avatar](/image/net_12.png)

准备：客户端的主机和服务端的主机都处于关闭状态，当用户打开客户端主机后，服务端的主机被动打开。B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求，即进入LISTEN状态。
* 客户端A的TCP进程创建传输控制块TCB，然后向B发送连接请求报文段，并将报文段首部中的同步位SYN = 1，并同时选择一个初始序号sep = x,此时客户端TCP进入同步已发送状态。TCP协议规定，SYN = 1的报文段不能携带数据，但要消耗一个序号位。
* 服务端收到客户端发来的连接请求后，如果同意连接，则向客户端发送连接确认报文。在确认报文中，将SYN和ACK都置1，ack = x + 1,并未自己初始化一个序号sep = y.这个报文也不能携带数据，并且也会消耗掉一个序列号。此时服务端进入同步收到状态。
* 客户端收到服务端的确认报文后，还需要向服务端再次发送确认报文。此时将ACK = 1，ack = y + 1,序列号sep = x + 1.TCP协议规定，此时的ACK报文段可以携带数据，如果不携带数据则不消耗序列号，下一次序列号继续以sep = x + 1开始。此时客户端进入已连接状态，当服务端收到确认报文段后也会进入已连接状态。然后就是相互传递数据了。<br/>
上面就是TCP连接的三次握手了，那么，为什么还需要第三次确认呢，最后一次的确认时多余的吗？<br/>
前面我们提到，TCP之间的数据传输存在正常、消息差错、确认消息丢失、确认消息延迟的四种情况。在客户端和服务端连接的过程中，在没有最后一次确认前的情况下，前三种都会正常。如果出现确认消息延迟，即在某种情况下，服务端发送给客户端的确认报文不是丢失，而是因为拥塞等原因出现了延迟，客户端在超时计时器结束后再次向服务端发送连接请求，后面正常连接开始数据传输，此时上一次延迟的确认报文到达了，如果没有第三次的确认，服务端就判断为又一次正常连接而一直等待客户端发送数据，但客户端不会做任何操作，从而导致资源浪费。<br/>

#### 四次挥手：

![avatar](/image/net_13.png)

TCP的四次挥手相对于连接的三次握手来说，要复杂一些。从上面的图例可以看到，多了一个步骤：<br/>
* A向B发送终止连接的报文段主动关闭连接，将报文首部的FIN控制位FIN = 1，sep = u,TCP协议规定，FIN控制位即使不携带数据，也要消耗一个序号位。此时A进入等待终止状态，等待B确认。
* 当B收到终止报文后立即确认并向A发送确认报文，ACK = 1，ack = u +1,并将自己的序列号sep = v,此时B进入关闭等待状态，通知应用进程是否还有数据需要向A发送，如果有，还是可以向A发送数据的。A收到B的终止报文后，进入终止等待2状态；
* 当B的应用进程没有数据需要发送后，B开始终止连接。B向A发送报文，FIN = 1,ACK = 1,ack = u+1,sep = w,此时B进入最后确认阶段。等待A的确认。
* A收到B的终止报文后，做出确认。ACK = 1,ack = w+1,sep = u+1,然后进入时间等待状态。所谓的时间等待状态，指的是此时A并没有释放连接，而是必须在“时间等待计时器”计时结束后才释放连接。该定时器时间标准为2分钟，但对于现在的网络来说可能比较长了。当B收到A的确认报文后，立即进入close状态。<br/><br/>
针对为什么A在最后向B发送确认报文后会通过定时器来等待一段时间，是因为确保确认报文的送达。确认报文有可能丢失，丢失后B会在超时后重发，如果A在没有等待就关闭了的话，就收不到B发送的关闭报文，B从而一直等待。<br/><br/>
除了“时间等待计时器”外。TCP还有“保活计时器”。试想这样一种场景，当服务器向客户端发送报文后，客户端由于一些原因除了问题，收不到服务端的报文，服务器就白白的一直等下去。那么此时“保活计时器”就发挥作用了，在计时结束后服务器还是没有收到客户端的报文，那么就默认客户端出问题了，然后关闭连接。服务端每收到一次客户端的报文，就刷新一次“保活定时器”。

### 4、Http/Https
Http(超文本传输协议)：

![avatar](/image/net_14.png)

试想，当我们在浏览器输入http://tsinghua.edu.cn/chn/yxsz/index.htm 并发起请求时，到我们看到页面，中间的过程发生了什么。<br/>
1、浏览器分析页面指向的url；<br/>
2、浏览器向DNS请求解析http://tsinghua.edu.cn/chn 的IP地址；<br/>
3、域名解析系统DNS解析出清华大学服务器的IP地址为xxxxxx；<br/>
4、浏览器域服务器建立TCP连接(IP地址为xxxxxx，端口为80)<br/>
5、浏览器发出请求文件报文：GET chn/yxsz/index.htm<br/>
6、服务器给出响应报文<br/>
7、释放TCP连接<br/>
8、浏览器展示请求结果<br/>

Http有两种报文：<br/>
* 请求报文：从客户端向服务端发送的报文
* 响应报文：服务端响应给客户端的报文

![avatar](/image/net_15.png)
* 开始行：用于区分是请求报文还是响应报文。在请求报文中开始行叫请求行，在响应报文中开始行叫状态行；
* 首部行：用来说明浏览器，服务器或报文主体的一些信息，可以不用，也可以有多行；
* 实体主体：请求报文和响应报文可能不会用到该字段。

eg：请求报文<br/>
![avatar](/image/net_16.png)

响应报文的状态行的状态码：
* 1XX 通知信息，表示请求收到了或正在处理
* 2XX 表示成功(200：请求成功)
* 3XX 表示重定向
* 4XX 表示客户的错误，比如请求链接拼写错误等(400：请求报文中错误信息；404：请求地址错误)
* 5XX 表示服务器出错(500：服务器内部错误，无法完成请求；503：服务器不可用，超载或者停机维护等；505：服务器不支持请求的http版本)

Cookie：<br/>
Http的操作过程是无状态的，但是可以通过使用Cookie来实现“记忆”功能。<br/>
Cookie是这样工作的。当用户张三访问某网站服务器时，服务器就为张三产生一个唯一识别码，并以此为索引在服务器的后端数据库中产生一个项目。然后在给张三的响应报文中的首部添加一行Set-cookie。当张三收到响应报文后，其浏览器管理的特定Cookie文件添加一行，其中包括服务器的主机名和cookie值。后面当张三再次访问该服务器时，在其请求报文中的首部行中都包括该cookie，服务器收到报文后就会有了“记忆”功能。

### 5、非对称/对称加密
对称加密：DES、3DES、AES；<br/>
非对称加密：RSA，生成公钥/私钥密码对；<br/>
关于https,以及SSL证书在Http中的使用：<br/>
https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA <br/>
https://mp.weixin.qq.com/s/DGIkZT26CBafJzpQgrqqdQ

### 6、Http 1.1、2.0的区别
关于Http 1.1存在的问题：</br>
* 长链接：虽然加入长链接可以减少建立和连接带来的消耗，但是不同的域名的链接不能复用，只能重新创建长链接，会耗费资源，并且给服务器带来巨大的压力；
* 在header中携带请求的数据量过大，造成流量的浪费，如果每次请求header的内容不变，但是header携带的数据量又很大的情况下，就会造成资源的浪费；
* HTTP 1.1虽然引入了pipelining来解决队头阻塞问题（Head-Of-Line Blocking），即浏览器可以同时发送多个请求给服务器，不必等到上一个请求返回之后再进行请求，但是服务器的处理是等处理完当前请求的响应之后，才会去处理下一个请求的响应，即使当前很多请求都已经处理完了，服务器还是得根据请求的顺序来进行响应；<br/>

针对Http 1.1的问题，Http 2.0进行了提升：<br/>
* 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
* 多路复用：对于HTTP1.1中，如果当前有多个请求，请求的发送都是串行执行的，对于宽带的利用效率不高，但是在HTTP 2.0中，多个请求可以并行请求，大大的提升了宽带的利用率；
* Header压缩：使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。
* 数据优先级：由于请求可以并发发送给服务器，但是服务器还是遵循先进先出的规则来处理请求，但是在HTTP 2.0中可以设置当前请求的优先级，这样服务器在处理请求的响应时，会优先返回优先级较高的请求；
* 服务端推送：对于请求，一般都是浏览器或者客户端发送给服务器，服务器处理之后再返回，但是在HTTP 2.0中服务器可以推送相关文件给客户端，客户端再进行相应的处理，而不必等客户端发送请求之后再返回给客户端；
### 7、HTTP缓存
HTTP每次请求都要建立一个连接同时请求结束后会断开连接，如果连续请求同一资源，需要多次建立和断开连接，这样其实是没必要的，所以HTTP也具备缓存功能，一定程度上提升了请求效率。HTTP缓存可分为两种，强制缓存和对比缓存：</br>
#### 强制缓存：
在Http 1.1之前，是通过Expires进行缓存的，客户端第一次进行请求的时候服务器会返回一个头字段为Expires的头信息，代表有效日期，客户端要对该日期进行保存，下一次请求该资源的时候会判断当前日期是否超过有效日期，没有就直接从缓存中获取。但是如果客户端与服务器日期不一致就可能出现Bug，因此在Http 1.1之后，采用Cache-Control来代替Expires：
* private：客户端可以缓存，为默认取值；
* public：客户端和代理服务器都可以缓存；
* max-age：xxx：缓存内容将在xxx秒后失效，指定了age后默认为private；
* no-cache：客户端不设置缓存，使用服务端对比缓存来验证缓存数据；
* no-store：不进行任何缓存。
#### 对比缓存
与强制缓存不同，对比缓存通过服务器来决定是否需要缓存，有两种方式：</br>
* Last-Modified/If-Modified-Since：Last-Modified，客户端在进行第一次请求的时候服务器会返回一个头字段名称为Last-Modified的日期代表服务器对该资源最后修改时间，客户端需要对该日期进行保存；If-Modified-Since，客户端在之后的请求中会在请求头中加入头字段If-Modified-Since，其内容为服务器返回的Last-Modified，服务器收到后会判断缓存是否有效，如果有效返回304告诉客户端从自己本地缓存读取数据，否则返回200并携带新的响应体同时更新Last-Modified，客户端收到响应后重新保存Last-Modified和数据。
* Etag/If-None-Match：tag是资源的一个标识，当资源修改后Etag值会改变，Etag是由服务器生成，Etag/If-None-Match判断过程和Last-Modified/If-Modified-Since基本一致，唯一区别是缓存有效即服务器返回304时前者会在响应头中加入Etag，而后者不会再响应头中加入Last-Modified。</br>

一般来说对比缓存要配合强制缓存使用，Expires和Cache-Control优先级最高，其次是Etag/If-None-Match，最后是Last-Modified/If-Modified-Since：</br>
![avatar](/image/net_crash.png)  </br>
### 8、TCP如何控制流量
