## 记录计算机基础、网络

### 1、计算机网络结构
![avatar](/image/net_1.png)

便于理解，通常采用五层协议的结构：<br/>

应用层：<br/>
应用层是通过应用进程间的交互来完成特定的网络应用。对于不同的网络应用对应着不同的应用层协议，比如常见的万维网应用的Http协议，支持文件传送的FTP协议等。<br/><br/>
传输层：<br/>
传输层为两个进程间的通信提供通用的数据传送服务。所谓通用，不是增对某一特定的网络应用，而是多种应用使用同一套传输协议，主要使用TCP/UDP两种协议：<br/>
传输控制协议TCP：提供面向连接的、可靠的数据传输服务，数据传输的单位为报文段。<br/>
用户数据报协议UDP：提供无连接的、提供最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输单位为用户数据报。<br/><br/>
网络层：<br/>
网络层负责为分组交换机上的不同主机提供通信服务。网络层把传输层产生的报文段或者用户数据报封装成分组或者包进行传送。由于网络层采用IP协议，因此分组也叫做IP数据报。庞大的互联网是由大量的异构网络通过路由器相连，采用无连接的网际协议IP和许多种路由选择协议，因此网络层也通常被叫做IP层。<br/><br/>
数据链路层：<br/>
两台主机进行数据交互时，总是在一段段链路上进行，这就需要专门的链路层协议。两个相连链路节点进行数据传送时，会先将网络层交下来的分组封装成帧，每一帧包含数据和必要的控制信息(同步信息、地址信息、差错控制信息等)。<br/><br/>
物理层：<br/>
数据在物理层是以比特为单位进行传输的。发送方发送1(或0)时，接收方应当收到0(或1).因此物理层需要通过不同的电压来代表0或1，以及接收方如何识别出发送方发送的比特。值得注意的时，传递信息所用到的一些物理媒介，比如网线，光缆等，并不数据物理层范围之类，而是在物理层的下面，通常称作0层。<br/><br/>

上面概述了网络结构中的每一层结构，那么实际的传输环境下，它们是如何运作的呢？<br/>
![avatar](/image/net_2.png)

如上图，当主机1的应用进程Ap1向主机2的应用进程Ap2传送数据时，Ap1先将数据交给应用层处理，并一层一层的根据对应的协议封装数据后，从上至下，然后通过路由将数据传送到Ap2的物理层，并由下至上解析数据，最后通过应用层交给网络应用处理数据，反之亦然。

### 2、TCP/UDP
#### UDP：
* UDP是无连接的，即发送数据前是不需要建立连接的，当然数据传输结束后也就没有断开连接的操作，因此节省了开销和发送数据前的时延；
* 使用最大努力交互，即不保证数据的可靠交互，因此主机不需要维持复杂的连接状态表；
* UDP是面向报文的。<br/><br/>
![avatar](/image/net_3.png)

当发送方的UDP收到应用层的报文后，在添加首部后就直接向下传递给网络层，对收到的报文不进行合并、拆分等操作；当收到网络层传递的报文后，直接去掉首部后就向上传递给应用层。那么UDP添加的首部是什么格式呢：<br/><br/>
![avatar](/image/net_4.png)

当传输层收到从IP层的UDP数据报时，就根据首部中的目的端口号，将UDP数据传递到对应的端口，上交到最终点应用进程。
* UDP没有拥塞控制，这对某些实时应用是很重要的；
* UDP支持一对一、一对多、多对一、多对多的交互通信；
* UDP首部开销小，只有8个字节，比TCP的20个字节的首部要短。
#### TCP：
概述：<br/>
* TCP是面向连接的运输层协议，在进行数据传输前必须先建立可靠连接，数据传输结束后需要释放已建立好的可靠连接，类似于我们生活中的打电话；
* TCP提供可靠的连接传输服务，保证传输数据的无差错、不丢失、不重复并按序到达；
* 每一条TCP连接只能有两个端点，即点对点连接；
* TCP提供全双工通信，通信双发在任何时候都可以发送数据，则得于TCP连接的两端都设有发送缓存和接受缓存。发送数据时，应用程序把数据发送给TCP缓存，就可以去做其他事了，TCP会在合适的时候从缓存里将数据发送出去；在接受数据时，TCP将IP层的数据写入缓存，应用程序在合适的时候就从缓存里取出数据；
* 面向字节流。虽然应用程序和TCP交互的是一块块大小不等的数据块，但TCP把这些数据块仅仅是当作一连串无结构的字节流，TCP并不知道所传输字节流的含义。如下图：<br/>
![avatar](/image/net_5.png)

TCP连接：<br/>
TCP的连接为点对点的连接，每一端通过套接字进行抽象，IP地址和端口号拼接成套接字。<br/>
Socket = IP地址:端口号<br/>
TCP连接 ::= {socket1 : socket2} = {(IP1:port1) : (IP2:port2)}<br/><br/>

可靠传输：<br/>
上面提到，TCP传输是可靠的，那么是什么样的工作原理来保证的呢。这里引入“停止等待”的概念，所谓停止等待，是TCP每发送完一组分组，就进入停止发送，等待对方确认。当收到对方确认后，才进行下一次发送。这里分情况讨论：<br/>
无差错情况：<br/>
![avatar](/image/net_6.png)

正常情况下，A发送消息给B，并等待B消息确认，当B确认消息后，A再发送消息M2.....依次有序的进行下去；<br/>

消息出现差错：<br/>
![avatar](/image/net_7.png)

当A发送消息M1给B，但是M1在发送的过程中存在差错，那么B收到M1后，就会丢弃M1，后面不进行任何操作。此时A已经进入等待状态，但是不可能一直等待下去，当超时计时器时间结束后，A会重发消息M1，后面就进入正常情况下的数据传输状态。<br/>

确认消息丢失：<br/>
![avatar](/image/net_8.png)

如图所示，当B收到A发送的消息M1后，并且确认M1无差错，那么就给A发送确认消息。但是确认消息丢失了，A在超时计时器结束后重新发送消息M1，B第二次收到M1后，丢弃重复的M1，并再次对A发送确认消息。<br/>

确认消息迟到：<br/>
![avatar](/image/net_9.png)

上面的情况是B收到M1后向A发送的消息迟到了，A在超时计时器结束后还是会向B发送M1，B收到M1后丢弃重复的M1，并再次向A发送确认消息，当A第二次再收到确认消息时，此时判断为消息迟到，则将重复的确认消息丢弃，不做任何操作。<br/><br/>

连续ARQ：<br/>
上面提到的可靠传输方式通常被称作“自动重传请求ARQ”，意思是重传的请求是发送方自动发起的。但是值得注意的是，每次发送消息都需要等待对方确认后才能发送下一个消息，这样导致传输效率，或者说信道利用率很低。怎么办呢，“连续ARQ”：<br/>

![avatar](/image/net_10.png)

又名滑动窗口协议，是TCP协议的精髓。如图锁所示，位于滑动窗口内的5个分组连续被发送，而不需要等待接收方的确认消息。当发送方每收到一次消息确认后，就将滑动窗口向前移动一格分组。<br/>

TCP虽然是面向字节流，但发送的数据单元为数据报。一个TCP报文分为首部和数据部分，TCP的全部功能都体现在首部中的各个字段控制。<br/>
![avatar](/image/net_11.png)

### 3、三次握手、四次挥手
三次握手以及四次挥手都是针对TCP，分别为TCP的连接与释放。先理解几个控制位概念：<br/>
* 确认ACK 仅当ACK = 1时确认号字段才有效，当ACK = 0 时确认号是无效的。TCP规定，在建立连接后所有传送报文段都必须把ACK置1。
* 同步SYN 在连接时用来同步序号。当SYN = 1，ACK = 0时，表示这是一条连接请求报文，若对方同意连接，则在响应报文中将SYN = 1，ACK= 1。因此，当SYN = 1表示这是一条连接请求或连接响应报文。
* 终止 用来释放连接。当FIN = 1时，表明此报文的发送发数据发送完毕，并且要求释放连接。
#### 三次握手：
![avatar](/image/net_12.png)

准备：客户端的主机和服务端的主机都处于关闭状态，当用户打开客户端主机后，服务端的主机被动打开。B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求，即进入LISTEN状态。
* 客户端A的TCP进程创建传输控制块TCB，然后向B发送连接请求报文段，并将报文段首部中的同步位SYN = 1，并同时选择一个初始序号sep = x,此时客户端TCP进入同步已发送状态。TCP协议规定，SYN = 1的报文段不能携带数据，但要消耗一个序号位。
* 服务端收到客户端发来的连接请求后，如果同意连接，则向客户端发送连接确认报文。在确认报文中，将SYN和ACK都置1，ack = x + 1,并未自己初始化一个序号sep = y.这个报文也不能携带数据，并且也会消耗掉一个序列号。此时服务端进入同步收到状态。
* 客户端收到服务端的确认报文后，还需要向服务端再次发送确认报文。此时将ACK = 1，ack = y + 1,序列号sep = x + 1.TCP协议规定，此时的ACK报文段可以携带数据，如果不携带数据则不消耗序列号，下一次序列号继续以sep = x + 1开始。此时客户端进入已连接状态，当服务端收到确认报文段后也会进入已连接状态。然后就是相互传递数据了。<br/>
上面就是TCP连接的三次握手了，那么，为什么还需要第三次确认呢，最后一次的确认时多余的吗？<br/>
前面我们提到，TCP之间的数据传输存在正常、消息差错、确认消息丢失、确认消息延迟的四种情况。在客户端和服务端连接的过程中，在没有最后一次确认前的情况下，前三种都会正常。如果出现确认消息延迟，即在某种情况下，服务端发送给客户端的确认报文不是丢失，而是因为拥塞等原因出现了延迟，客户端在超时计时器结束后再次向服务端发送连接请求，后面正常连接开始数据传输，此时上一次延迟的确认报文到达了，如果没有第三次的确认，服务端就判断为又一次正常连接而一直等待客户端发送数据，但客户端不会做任何操作，从而导致资源浪费。<br/>

#### 四次挥手：

![avatar](/image/net_13.png)

TCP的四次挥手相对于连接的三次握手来说，要复杂一些。从上面的图例可以看到，多了一个步骤：<br/>
* A向B发送终止连接的报文段主动关闭连接，将报文首部的FIN控制位FIN = 1，sep = u,TCP协议规定，FIN控制位即使不携带数据，也要消耗一个序号位。此时A进入等待终止状态，等待B确认。
* 当B收到终止报文后立即确认并向A发送确认报文，ACK = 1，ack = u +1,并将自己的序列号sep = v,此时B进入关闭等待状态，通知应用进程是否还有数据需要向A发送，如果有，还是可以向A发送数据的。A收到B的终止报文后，进入终止等待2状态；
* 当B的应用进程没有数据需要发送后，B开始终止连接。B向A发送报文，FIN = 1,ACK = 1,ack = u+1,sep = w,此时B进入最后确认阶段。等待A的确认。
* A收到B的终止报文后，做出确认。ACK = 1,ack = w+1,sep = u+1,然后进入时间等待状态。所谓的时间等待状态，指的是此时A并没有释放连接，而是必须在“时间等待计时器”计时结束后才释放连接。该定时器时间标准为2分钟，但对于现在的网络来说可能比较长了。当B收到A的确认报文后，立即进入close状态。<br/><br/>
针对为什么A在最后向B发送确认报文后会通过定时器来等待一段时间，是因为确保确认报文的送达。确认报文有可能丢失，丢失后B会在超时后重发，如果A在没有等待就关闭了的话，就收不到B发送的关闭报文，B从而一直等待。<br/><br/>
除了“时间等待计时器”外。TCP还有“保活计时器”。试想这样一种场景，当服务器向客户端发送报文后，客户端由于一些原因除了问题，收不到服务端的报文，服务器就白白的一直等下去。那么此时“保活计时器”就发挥作用了，在计时结束后服务器还是没有收到客户端的报文，那么就默认客户端出问题了，然后关闭连接。服务端每收到一次客户端的报文，就刷新一次“保活定时器”。

### 4、非对称/对称加密
### 5、Http/Https
