## 记录java相关！

### 1、在java中，public、privite、protected修饰符
在java中，public、privite、protected三种修饰符用来修饰类以及类的成员变量和方法。</br>
修饰类的成员变量以及方法时：privite，变量和方法只能在类中可见，对子类以及其他包中的类是不可见的，方法不可见，那么子类也无法对父类中privite修饰的方法进行重写。public，对子类以及其他包里的类都可见。protected，子类以及同一个包中的类均可访问。可以这么理解，只要方法和变量不是private修饰，那么就对其子类可见。</br>
修饰类时：privite修饰类，那么类中的所有数据(变量，方法)都将被隐藏，一般没有太大意义，因为我们定义一个类，就是用来创建对象并调用的，弄成隐藏，还有什么意义（除了内部类，一般的类也不允许这么修饰）。public修饰类，该类对所有类可见。protected修饰类，该类只能对同包中的类可见。

* 默认情况下，作用域相当于protected；
* 类的权限设定会约束成员的权限，这应该很好理解。

### 2、final修饰符

final字段可修饰类、方法以及变量。

* 对于一个final变量，如果是基本数据类型的变量，那么其值在初始化之后是不可以改变的。一个既是static又是final修饰的变量只占据一段不能改变的内存；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
* 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法,不能被子类重写。<br/>
* 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

### 3、static修饰符

通常情况下，会出现多个类在内存区域共享一个数据，这是我们就通过static来修饰这个数据。static可以修饰类，方法、变量以及代码块，java虚拟机会为static修饰的变量等分配唯一的内存区域，且周期跟随进程。使用static需要注意以下几点：

* 静态成员同样遵循public、private、protected修饰符的约束；
* 静态方法中不可以使用this字段；
* 静态方法不可以直接调用非静态方法；
* 方法中的局部变量不能声明为static，即使是静态方法也不行。

### 4、封装、继承、多态
java是一种面向对象的语言，在它的眼里，万物皆对象。而面向对象的三大特点，就是封装、继承、多态。<br/>
封装：面向对象编程的核心思想，将对象的属性和行为封装起来，其载体为类，只为外部提供相关调用，而隐藏具体的实现细节。<br/>

继承：类与类之间存在着某种关系，继承就是特殊的一种类与类之间关系。<br/>
* 子类可以继承父类的方法和属性，也可以增加父类不具备的属性和方法，或者直接重写父类中的某些方法。
* 方法重写(覆盖)：子类中将父类的成员方法的名称和参数保留，重写实现内容，更改修饰权限，或返回值。如果只重写实现内容，那么就叫重构。值得注意的是，更改修饰权限只能从小的范围到大的范围，父类中为protected，那么子类只能修改为public；修改返回类型时，子类的返回类型必须是父类的返回类型的子类，而不能随便类似的将返回类型int更改为string。
* 在实例化子类时，会自动调用父类的无参构造函数，先实例化父类，再实例化子类；
* Object类是所有类的父类；
* 向上转型：Animal animal = new Dog();向下转型：Dog dog = (Dog) animal;
* 使用instanceof判断对象类型；
* 方法重载：同一个类中允许存在一个以上的同名方法，只要这些方法的参数个数、类型、顺序不同即可。可以知道，编译器是利用方法名，方法参数的类型、个数以及顺序来确定类中的方法是否唯一的。

多态：将父类对象，应用于之类的特征，就是多态。多态的实现依赖于抽象类和接口。<br/>
* 非抽象类中不可以有抽象方法，抽象类中可以有非抽象方法；
* 接口是存粹的抽象类，所有的方法都没有实体；
* 接口中定义的方法必须是public或abstract；
* 在接口中定义的任何字段都自动是static和final的。

### 内部类

### 泛型
### 枚举
### 多线程
### 类加载过程
