## 记录剑指offer中的算法！

### 算法复杂度分析

所有好的算法应该具备时效高和存储低的特点。这里的「时效」是指时间效率，也就是算法的执行时间，对于同一个问题的多种不同解决算法，执行时间越短的算法效率越高，越长的效率越低；「存储」是指算法在执行的时候需要的存储空间，主要是指算法程序运行的时候所占用的内存空间。在如见硬件条件变得越来越好的情况下，更多的考虑的是时间复杂度的分析，下面是主要时间复杂度的比较图：
![avatar](/image/time.jpg)

### 常见排序、查找算法

### 长度为n的数组，每一项都不大与m，排序

### 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
其实，这是数学上的兔子问题：<br/>
在第一个月有一对刚出生的小兔子，在第二个月小兔子变成大兔子并开始怀孕，第三个月大兔子会生下一对小兔子，并且以后每个月都会生下一对小兔子。 如果每对兔子都经历这样的出生、成熟、生育的过程，并且兔子永远不死，那么兔子的总数是如何变化的?
通过规律总结，我们发现：

* 前一个月的大兔子对数就是下一个月的小兔子对数。</br>
* 前一个月的大兔子和小兔子对数的和就是下个月大兔子的对数。
* 兔子总对数的排列规则为1 1 2 3 5 8 13 21...当前n的值，是n-1、n-2两项之和。
<pre class="prettyprit lang-java">
public int Fibonacci(int n) {
        if(n==0||n==1){
            return  n;
        } else {
            int[] a = new int[n + 1];
            a[0] = 0;
            a[1] = 1;
            for(int i = 2;i < n + 1;i++){
                a[i] = a[i-1] + a[i-2];
            }
            return a[n];
        }
    }
</pre>

### 鸡兔同笼问题(一个笼子里只有鸡和兔子，从上看一共有35个头，从下看一共有94只脚，那么笼子里鸡兔各有多少只？)。
思路：假如我们让兔子和鸡同时抬起两只脚，那么此时地上的脚是不是就只可能是兔子的，并且此时地上的脚除以2，就是兔子的个数，从而鸡的数量也迎刃而解了！
<pre class="prettyprit lang-java">
public void checkenRabbit(int head,int foot){
    int chicken;
    int rabbit;
    rabbit = (foot - head * 2) / 2;
    chicken = (foot - rabbit * 4) / 2;
    System.out.println("chicken:" + chicken + " rabbit:" + rabbit);
}
</pre>
